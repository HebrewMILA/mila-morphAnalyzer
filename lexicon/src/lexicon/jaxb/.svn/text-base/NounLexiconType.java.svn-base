//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v1.0.4-b16-fcs 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2005.04.11 at 01:39:43 GMT+02:00 
//


package lexicon.jaxb;


/**
 * מבנה זה מגדיר שמות עצם.
 * צורה בסיסית של שמות העצם היא צורת היחיד (זכר או נקבה) ובמקרים מסויימים (בעלי תכונת +חי) יש צורת נקבה הניתנת לגזירה מצורת הזכר.
 * רצוי היה לאגד תחת מזהה יחיד ועיול יחיד במילון את צורות הזכר והנקבה של אותו העצם ע"י add, אולם, כתלות ביישום, גם הוספתם של שמות עצם בנקבה שלהן גם צורת זכר כעיול נפרד יתקבלו.
 * אילוץ:
 * ======
 * אם המין (gender) הוא נקבה (feminine), אזי אין משמעות לתכונת ה- feminine (צורן נקבה) ולכן לא תופיע תכונת ה- feminine (צורן נקבה) כאשר ערך התכונה מין (gender) הוא נקבה (feminine). למעשה, הערך irrelevant של תכונת feminine כמוהו כאי הגדרת התכונה.
 * אילוץ:
 * ======
 * אם הריבוי (number) הוא רבים (plural), אזי אין משמעות לתכונת ה- plural (צורן ריבוי) ולכן לא תופיע תכונת ה-  plural (צורן ריבוי) כאשר ערך התכונה ריבוי (number) הוא רבים (plural). למעשה, הערך irrelevant של תכונת plural כמוהו כאי הגדרת התכונה.
 * אילוץ:
 * ======
 * אם dual="true" אזי לא יכול להיות ש- number="singular". ז"א שמילה לא יכול להיות ביחיד וגם בזוגי בעת ובעונה אחת.
 * אילוץ:
 * ======
 * אם deverbal="true" אזי dual="false".
 * אילוץ:
 * ======
 * אם direction="true" אזי המחרוזת חייבת להסתיים באות ה'.
 * אילוץ:
 * ======
 * root ימורכב בד"כ מ- 3 אותיות. ישנם שורשים בני 2 אותיות וגם כאלה בני 4 ו- 5. במקרים מיוחדים ניתן לאלץ מילים להכנס לתבנית שורש/משקל כשורש -- וראו על "יצירת שורשים חדשים" בספרו של עוזי אורנן "המילה האחרונה" פרק 6.
 * אילוץ:
 * ======
 * אם מופיעה תכונת שורש (root) אזי תופיע גם תכונת משקל (pattern). ז"א התכונות root ו- pattern חייבות להופיע יחד או לא להופיע כלל. העם לכך הוא בהנחה כי השילוב של שורש ומשקל הוא בעל משמעות ומכיל את המידע הדרוש בשעה שאחד מהם בלבד מכיל מידע חסר ולא מספק. יתירה מזאת, ההנחה היא שאין השורש חשוב יותר מהמשקל ואין המשקל חשוב יותר מהשורש. וראו דיון על כך בספרו של עוזי אורנן "המילה האחרונה" פרק 2 סעיף 2.3 ע"מ 28-32.
 * אילוץ:
 * ======
 * אם number="dual" או number="dual and plural", אזי dual="false".
 * אם מהערך המתואר ניתן לגזור צורת זוגי אזי dual="true".
 * אם מהערך המתואר לא ניתן לגזור צורת זוגי אזי dual="false", וזה גם הערך כברירת מחדל.
 * אילוץ:
 * ======
 * inflectionBase יופיע רק אם הוא שונה מהמילה עצמה. inflectionBase לא יופיע ריק.
 * 
 * Java content class for NounLexiconType complex type.
 * <p>The following schema fragment specifies the expected content contained within this java content object. (defined at file:/C:/hebrew_lexicon_new.xsd line 185)
 * <p>
 * <pre>
 * &lt;complexType name="NounLexiconType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;choice maxOccurs="unbounded" minOccurs="0">
 *           &lt;element name="add" type="{}NounExceptionType" maxOccurs="unbounded" minOccurs="0"/>
 *           &lt;element name="replace" type="{}NounExceptionType" maxOccurs="unbounded" minOccurs="0"/>
 *           &lt;element name="remove" type="{}NounExceptionType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;/choice>
 *       &lt;/sequence>
 *       &lt;attribute name="acronym" type="{}TriStateType" default="unspecified" />
 *       &lt;attribute name="definiteness" type="{}TriStateType" default="false" />
 *       &lt;attribute name="deverbal" type="{}TriStateType" default="unspecified" />
 *       &lt;attribute name="direction" type="{}TriStateType" default="false" />
 *       &lt;attribute name="dual" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *       &lt;attribute name="feminine" type="{}FeminineType" default="irrelevant" />
 *       &lt;attribute name="gender" type="{}GenderType" default="masculine" />
 *       &lt;attribute name="inflectionBase" type="{http://www.w3.org/2001/XMLSchema}token" default="" />
 *       &lt;attribute name="inflectionPattern" type="{http://www.w3.org/2001/XMLSchema}token" default="" />
 *       &lt;attribute name="ipSource" type="{http://www.w3.org/2001/XMLSchema}token" default="" />
 *       &lt;attribute name="number" type="{}NumberType" default="singular" />
 *       &lt;attribute name="pattern" type="{http://www.w3.org/2001/XMLSchema}token" default="" />
 *       &lt;attribute name="plural" type="{}PluralType" default="im" />
 *       &lt;attribute name="root" type="{http://www.w3.org/2001/XMLSchema}token" default="" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 */
public interface NounLexiconType {


    /**
     * Gets the value of the direction property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getDirection();

    /**
     * Sets the value of the direction property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setDirection(java.lang.String value);

    /**
     * Gets the value of the feminine property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getFeminine();

    /**
     * Sets the value of the feminine property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setFeminine(java.lang.String value);

    /**
     * Gets the value of the gender property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getGender();

    /**
     * Sets the value of the gender property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setGender(java.lang.String value);

    /**
     * Gets the value of the deverbal property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getDeverbal();

    /**
     * Sets the value of the deverbal property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setDeverbal(java.lang.String value);

    /**
     * Gets the value of the plural property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getPlural();

    /**
     * Sets the value of the plural property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setPlural(java.lang.String value);

    /**
     * Gets the value of the definiteness property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getDefiniteness();

    /**
     * Sets the value of the definiteness property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setDefiniteness(java.lang.String value);

    /**
     * Gets the value of the ipSource property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getIpSource();

    /**
     * Sets the value of the ipSource property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setIpSource(java.lang.String value);

    /**
     * Gets the value of the inflectionPattern property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getInflectionPattern();

    /**
     * Sets the value of the inflectionPattern property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setInflectionPattern(java.lang.String value);

    /**
     * Gets the value of the dual property.
     * 
     */
    boolean isDual();

    /**
     * Sets the value of the dual property.
     * 
     */
    void setDual(boolean value);

    /**
     * Gets the value of the number property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getNumber();

    /**
     * Sets the value of the number property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setNumber(java.lang.String value);

    /**
     * Gets the value of the root property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getRoot();

    /**
     * Sets the value of the root property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setRoot(java.lang.String value);

    /**
     * Gets the value of the acronym property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getAcronym();

    /**
     * Sets the value of the acronym property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setAcronym(java.lang.String value);

    /**
     * Gets the value of the inflectionBase property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getInflectionBase();

    /**
     * Sets the value of the inflectionBase property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setInflectionBase(java.lang.String value);

    /**
     * Gets the value of the AddOrReplaceOrRemove property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the AddOrReplaceOrRemove property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAddOrReplaceOrRemove().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link lexicon.jaxb.NounLexiconType.Add}
     * {@link lexicon.jaxb.NounLexiconType.Replace}
     * {@link lexicon.jaxb.NounLexiconType.Remove}
     * 
     */
    java.util.List getAddOrReplaceOrRemove();

    /**
     * Gets the value of the pattern property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String}
     */
    java.lang.String getPattern();

    /**
     * Sets the value of the pattern property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String}
     */
    void setPattern(java.lang.String value);


    /**
     * מבנה זה משמש להוספת צורות נוספות.
     * בפרט -- כתיב שונה, צורות זוגי, אפשרויות נוספות לנטייה מסויימת.
     * בברירת מחדל, אם נוספת מילה אשר עקב תכונותיה מהווה בסיס לנטייה (למשל, צורת זכק יחיד בנפרד, או צורת הנסמך, או צורת הרבים), אזי יופקו גם נטיות נוספות. כדי לדכא אפשרות זאת יש להשתמש בתכונות inflectPossessive="false" ו-inflectConstruct="false".
     * 
     * Java content class for add element declaration.
     * <p>The following schema fragment specifies the expected content contained within this java content object. (defined at file:/C:/hebrew_lexicon_new.xsd line 234)
     * <p>
     * <pre>
     * &lt;element name="add" type="{}NounExceptionType"/>
     * </pre>
     * 
     */
    public interface Add
        extends javax.xml.bind.Element, lexicon.jaxb.NounExceptionType
    {


    }


    /**
     * מבנה זה משמש להסרת צורות שנוצרו באופן אוטומטי, ובכך לסמן למנתח צורני שעושה שימוש בלקסיקון, שלא לייצר (בעצם שימחוק את הצורות האלה, או שלא ייצרן כלל).
     * במקרים בהם הצורה שיש למחוק היא צורה אשר מהווה בסיס לנטיות, יש לציין אם על הצורה להמחק על הנטיות שלה או שמא, להמחק בעצמה, אך לאפשר את הנטיות.
     * באופן כללי, יש להעדיף שימוש רחב ב- add וב- replace תחת השימוש ב- remove, כדי לפשט את המימוש וכדי ליצור מנגנון אחיד להבנת הלקסיקון.
     * 
     * Java content class for remove element declaration.
     * <p>The following schema fragment specifies the expected content contained within this java content object. (defined at file:/C:/hebrew_lexicon_new.xsd line 252)
     * <p>
     * <pre>
     * &lt;element name="remove" type="{}NounExceptionType"/>
     * </pre>
     * 
     */
    public interface Remove
        extends javax.xml.bind.Element, lexicon.jaxb.NounExceptionType
    {


    }


    /**
     * מבנה זה משמש להחלפת צורות קיימות באחרות.
     * בפרט -- ריבוי יוצא דופן, סמיכות וכ'.
     * בברירת מחדל, אם מוחלפת מילה אשר עקב תכונותיה מהווה בסיס לנטייה (למשל, צורת זכק יחיד בנפרד, או צורת הנסמך, או צורת הרבים), אזי יופקו גם נטיות נוספות, אשר יחליפו את הנטיות הקיימות שהופקו. כדי לדכא אפשרות זאת יש להשתמש בתכונות inflectPossessive="false" ו-inflectConstruct="false".
     * 
     * Java content class for replace element declaration.
     * <p>The following schema fragment specifies the expected content contained within this java content object. (defined at file:/C:/hebrew_lexicon_new.xsd line 243)
     * <p>
     * <pre>
     * &lt;element name="replace" type="{}NounExceptionType"/>
     * </pre>
     * 
     */
    public interface Replace
        extends javax.xml.bind.Element, lexicon.jaxb.NounExceptionType
    {


    }

}
