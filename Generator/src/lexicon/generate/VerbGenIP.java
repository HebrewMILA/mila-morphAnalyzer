/*
 * Created on 05/09/2005
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package lexicon.generate;

import java.util.List;
import java.util.StringTokenizer;
import lexicon.contents.exception_types.VerbExceptionType;
import lexicon.dbUtils.Inflections;
import lexicon.stringUtils.StrUtils;
import lexicon.stringUtils.Translate;

/**
 * @author daliabo
 * 
 * TODO To change the template for this generated  comment go to Window -
 * Preferences - Java - Code Style - Code Templates
 */
public class VerbGenIP implements VerbInterface 
{
	private String root = "";
	private String inflectedVerb = null;
	private String surface = "";
	private String register = "";
	private String spelling = "";
	private String baseTransliterated = "";
	private String baseUndot = "";
	private String baseLexiconPointer = "";
	private String tense = "";
	private String binyan = "";
	private String PGN = "";
	private String hebRoot = "";
	private String construct = "";
	private String pos = "verb";
	private String baseDefiniteness = "f";
	private String baseNumber;
	private String baseGender;
	private String basePerson;
	private String valence;
	private String dottedLexiconItem;
	private String participleType = "unspecified";
	private int intInflectedPattern;
	
	StringTokenizer stPGN10 = null;
	StringTokenizer stPerson10 = null;
	StringTokenizer stGender10 = null;
	StringTokenizer stNumber10 = null;
	StringTokenizer stGender4 = null;
	StringTokenizer stNumber4 = null;
	StringTokenizer stPerson4 = null;
	StringTokenizer stPGNBeinoni = null;
	StringTokenizer stPGNImperative = null;

	public List replaceExceptionList = null;
	public List removeExceptionList = null;
	public String suffixFunction = "unspecified";
	private String definitenessVal = "f";

	boolean inflectInfinitivel;
	boolean inflectInfinitiveb;
	boolean inflectBeinoni;
	boolean inflectBeinoniPossessive = true;
	boolean inflectBeinoniConstruct = true;
	boolean inflectPast = true;
	boolean inflectFuture = true;
	boolean inflectImperative = true;
	boolean inflectInfinitive = true;
	boolean inflectBareInfinitive = true;
	boolean replaceRemoveInfinitive = false;
	boolean inflectInfinitiveIndependent = false;
	boolean exceptionInflectBeinoniPossessive = false;
	boolean bareInfinitiveException = false;
	
	String table = "";

	/**
	 * @param intInflectedPattern
	 *            The intInflectedPattern to set.
	 */
	public void setIntInflectedPattern(int intInflectedPattern) 
	{
		this.intInflectedPattern = intInflectedPattern;
	}

	/**
	 * @return Returns the hebRoot.
	 */
	public String getHebRoot() 
	{
		return hebRoot;
	}

	/**
	 * @param hebRoot
	 *            The hebRoot to set.
	 */
	public void setHebRoot(String hebRoot) 
	{
		this.hebRoot = hebRoot;
	}

	public VerbGenIP(String root) 
	{
		this.root = root;
	}

	/**
	 * This methos handles filling the inflection record with values to be
	 * inserted to the database
	 * 
	 * @throws Exception
	 */
	private void populateDBTable() throws Exception 
	{
		Inflections inf = new Inflections();
		inf.setRegister(this.register);
		inf.setSpelling(this.spelling);
		inf.setBasePos(pos);
		inf.setBaseUndottedLItem(baseUndot);
		inf.setBaseTransliteratedLItem(baseTransliterated);
		inf.setBaseundottedLItem(baseUndot);
		inf.setBaseLexiconPointer(baseLexiconPointer);
		inf.setBinyan(binyan);
		inf.setRoot(hebRoot);
		inf.setTense(tense);
		inf.setPGN(PGN);
		inf.setSuffixStatus(construct);
		inf.setBaseGender(baseGender);
		inf.setBaseNumber(baseNumber);
		inf.setBasePerson(basePerson);
		inf.setBaseDefinitness(baseDefiniteness);
		inf.setSurface(this.surface);
		inf.setTransliterated(this.inflectedVerb);
		inf.setSuffixFunction(suffixFunction);
		inf.setDottedLexiconItem(dottedLexiconItem);
		inf.setType(participleType);
		inf.setPolarity("u"); //unspecified
		inf.setValue("");
		inf.setTable(this.table);
		inf.insertItem();
	}

	/**
	 * This method is used for handling remove and replace exceptions <br>
	 * It checks whether there is a matching value for the current generated
	 * form <br>
	 * The decision is taken by testing the PGN,tense and accusation values <br>
	 * 
	 * @param PGN -
	 *            person/gender/number value generated by the generation program
	 * @param tense -
	 *            the tense of the generated form
	 * @param accusativeSuffix -
	 *            currently we are not handling accusative values
	 * @param exceptionList -
	 *            remove/replace exception list for the current lexicon item
	 * @param action -
	 *            remove/replace
	 * @return - boolean value: true - replacement/removement has been done
	 * @throws Exception
	 */
	public boolean replaceRemoveException(String GeneratedPGN, String tense,
			String baseGender, String baseNumber, String basePerson,
			List exceptionList, boolean beinoniConstruct, int action) throws Exception 
		{
		boolean match = false;
		String orifinalInflectedVerb = inflectedVerb;
		if (exceptionList != null) 
		{
			int size = exceptionList.size();
			for (int i = 0; i < size; i++) 
			{
				VerbExceptionType verbExceptionType = new VerbExceptionType();
				verbExceptionType.open(((Integer) exceptionList.get(i)).intValue());
				String exceptionTense = verbExceptionType.getTense();
				String exceptionGender = verbExceptionType.getGender();
				String exceptionNumber = verbExceptionType.getNumber();
				String exceptionPerson = verbExceptionType.getPerson();
				
				if(exceptionPerson.equals("3") && (tense.equals("beinoni") || tense.equals("beinoniPaul")))
					exceptionPerson="any";

				boolean exceptioniBeinoniConstruct = verbExceptionType.isBeinoniConstruct();
				exceptionInflectBeinoniPossessive = verbExceptionType.isInflectBeinoniPossessive();

				String exceptionPGN = verbExceptionType.getPgn();
				/*System.out.println("----------------------------");
				System.out.println(action + " handling");
				System.out.println("exceptionTense =" + exceptionTense);
				System.out.println("exceptionGender =" + exceptionGender);
				System.out.println("exceptionNumber =" + exceptionNumber);
				System.out.println("exceptionPerson =" + exceptionPerson);

				System.out.println("exceptionPGN =" + exceptionPGN);
				System.out.println("exceptioniBeinoniConstruct ="
						+ exceptioniBeinoniConstruct);
				System.out.println("tense =" + tense);
				System.out.println("baseGender =" + baseGender);
				System.out.println("baseNumber =" + baseNumber);
				System.out.println("basePerson =" + basePerson);
				System.out.println("GeneratedPGN  =" + GeneratedPGN);
				System.out.println("beinoniConstruct  =" + beinoniConstruct);
				System.out.println("exceptionInflectBeinoniPossessive  ="+ exceptionInflectBeinoniPossessive);
				*/
				if (exceptionTense.equals(tense)
						&& (exceptionGender.equals(baseGender)
								&& exceptionNumber.equals(baseNumber) && exceptionPerson.equals(basePerson))
						&& (exceptionPGN.equals(GeneratedPGN))
						&& (beinoniConstruct == exceptioniBeinoniConstruct) ) 
				{

					if (action == 1) 
					{
						//System.out.println("exception action = replace ");
						inflectedVerb = verbExceptionType.getTransliterated();
						surface = Translate.Eng2Heb(inflectedVerb);
						//System.out.println("exception transliterated  ="+ inflectedVerb);
						//System.out.println("exception transliterated  ="+ surface);
						if (tense.equals("infinitive")) 
						{
							//בודקים בכל"מ
							if (inflectedVerb.charAt(0) == orifinalInflectedVerb.charAt(0)) 
							{
								populateDBTable();
								match = true;
							} 
							else 
							{
								inflectedVerb = orifinalInflectedVerb;
								surface = Translate.Eng2Heb(inflectedVerb);
							}
						} 
						else if (tense.equals("beinoni")) 
						{
							if (exceptionPGN.equals("unspecified")
									&& !beinoniConstruct
									&& baseDefiniteness.equals("f")) 
							{
								participleType = "noun";
								populateDBTable();
								participleType = "adjective";
								populateDBTable();
								participleType = "verb";
								populateDBTable();
							} 
							else if (!exceptionPGN.equals("unspecified")|| beinoniConstruct) 
							{
								participleType = "noun";
								populateDBTable();
							} else if (baseDefiniteness.equals("tt")) 
							{
								participleType = "noun";
								populateDBTable();
								participleType = "adjective";
								populateDBTable();
								participleType = "verb";
								baseDefiniteness = "s";
								populateDBTable();
							} else if (tense.equals("passiveParticiple")) 
							{
								if (exceptionPGN.equals("unspecified")
										&& !beinoniConstruct
										&& baseDefiniteness.equals("f")) 
								{
									participleType = "adjective";
									populateDBTable();
									participleType = "verb";
									populateDBTable();
								} 
								else if (beinoniConstruct) 
								{
									participleType = "noun";
									populateDBTable();
								} 
								else if (baseDefiniteness.equals("tt")) 
								{
									participleType = "noun";
									populateDBTable();
									participleType = "adjective";
									populateDBTable();
									participleType = "verb";
									baseDefiniteness = "s";
									populateDBTable();
								}
							}
						} 
						else 
						{
							populateDBTable();
							match = true;
						}
						//System.out.println("----------------------------");
						return match;
					} 
					else if (action == 2) 
					{
						System.out.println("exception action = remove ");
						match = true;
						//System.out.println("----------------------------");
						return match;
					}
				}
			}
		}
		//System.out.println("----------------------------");
		return match;
	}

	/**
	 * This methos is used for handling add exceptions <br>
	 * It scans the addExceptionList and populate the database with each of the
	 * values
	 * 
	 * @param exceptionList -
	 *            addExceptionList
	 * @throws Exception
	 */
	public void AddException(List exceptionList) throws Exception 
	{
		//System.out.println("exceptionList.size()" + exceptionList.size());
		StringTokenizer accusativeTokens = null;
		StringTokenizer PGNTokens = null;
		int size = exceptionList.size();
		for (int i = 0; i < size; i++) 
		{
			VerbExceptionType verbExceptionType = new VerbExceptionType();
			verbExceptionType.open(((Integer) exceptionList.get(i)).intValue());
			pos = "verb";
			baseGender = verbExceptionType.getGender();
			baseNumber = verbExceptionType.getNumber();
			basePerson = verbExceptionType.getPerson();
			spelling = verbExceptionType.getSpelling();
			register = verbExceptionType.getRegister();
			surface = verbExceptionType.getUndotted();
			//System.out.println(surface);
			inflectedVerb = verbExceptionType.getTransliterated();
			tense = verbExceptionType.getTense();
			PGN = verbExceptionType.getPgn();
			suffixFunction="unspecified";
			boolean isBeinoniConstruct = verbExceptionType.isBeinoniConstruct();
			//החלטנו לא לייצר מקור
			if (tense.equals("bareInfinitive"))
				continue;
			if (tense.equals("beinoni")) 
			{
				pos = "participle";
				if (isBeinoniConstruct) 
				{
					suffixFunction = "unspecified";
					baseDefiniteness = "tf";
					participleType = "noun";
					construct = "true";
				} 
				else if (!PGN.equals("unspecified")) 
				{
					suffixFunction = "possessive";
					baseDefiniteness = "tf";
					participleType = "noun";
					construct = "unspecified";

				} 
				else if (PGN.equals("unspecified")) 
				{
					construct = "false";
					suffixFunction = "unspecified";
					participleType = "noun";
					populateDBTable();
					participleType = "adjective";
					populateDBTable();
					participleType = "verb";
					populateDBTable();
				}

			} 
			else if (tense.equals("infinitive")) 
			{
				construct = "unspecified";
				participleType = "unspecified";
				//handle inflected infinitive
				if (!PGN.equals("unspecified")) 
				{
					suffixFunction = "accusative or nominative";
					baseDefiniteness = "f";

					//handle non inflected infinitive
				} 
				else if (PGN.equals("unspecified")) 
				{
					suffixFunction = "unspecified";
					baseDefiniteness = "f";
				}
				populateDBTable();
			} 
			else if (tense.equals("passiveParticiple")) 
			{
				pos = "passiveParticiple";
				tense = "beinoni";
				basePerson = "any";
				PGN = "unspecified";
				participleType = "adjective";
				if (isBeinoniConstruct) 
				{
					baseDefiniteness = "tf";
					construct = "true";
				} 
				else
					construct = "false";
				populateDBTable();
			}
			else
				populateDBTable();

			boolean exceptioniBeinoniDefiniteness = verbExceptionType.isBeinoniDefiniteness();
			if (exceptioniBeinoniDefiniteness) 
			{
				inflectedVerb = "h" + verbExceptionType.getTransliterated();
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.println("exception transliterated  ="+ inflectedVerb);
				baseDefiniteness = "tt";
				participleType = "noun";
				populateDBTable();
				participleType = "adjective";
				populateDBTable();
				participleType = "verb";
				baseDefiniteness = "s";
				populateDBTable();
			}
		}
	}

	private void setAttributes(String tense, String pos, String PGN,
			String basePerson, String baseGender, String baseNumber,
			String construct, String accusativeSuffix, String suffixFunction,
			String suffixNumber, String suffixGender, String suffixPerson,
			String baseDefiniteness) {
		this.tense = tense;
		this.PGN = PGN;
		this.pos = pos;
		this.construct = construct;
		this.basePerson = basePerson;
		this.baseGender = baseGender;
		this.baseNumber = baseNumber;
		this.suffixFunction = suffixFunction;
		this.baseDefiniteness = baseDefiniteness;
		participleType = "unspecified";
	}

	public void generateBareInfinitive(String prefix, String inside,int index1, int index2, int index3, int index4, String suffix) throws Exception 
	{
	    //System.out.println("(F) VerbGenIP: generateBareInfinitive()");
		if (inflectBareInfinitive) 
		{
			//Bare infinitive is like 'to infinitive' with out the 'to':
			// - by shuly definition לשמור -- שמור
			setAttributes("bareInfinitive", "verb", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "f");
			//System.out.println();
			//System.out.println("generate bare infinitive");
			StringBuffer inflected = null;

			inflected = new StringBuffer().append(prefix).append(root.substring(index1, index2)).append(inside).append(root.substring(index3, index4)).append(suffix);

			inflectedVerb = inflected.toString();
			surface = Translate.Eng2Heb(inflectedVerb);
			if (!replaceRemoveException("unspecified", tense, "unspecified","unspecified", "unspecified", replaceExceptionList, false,REPLACE)
				&& !replaceRemoveException("unspecified", tense,"unspecified", "unspecified", "unspecified",removeExceptionList, false, REMOVE))
				populateDBTable();
			//used for inflectPattern58() for נמס - if we enter exception type
			// of tense bareInfinitive we will create duplicates
			else
				bareInfinitiveException = true;

			//System.out.println("(F) VerbGenIP: generateBareInfinitive() generate infinitive without prefix l - for bkm prefixes");
		} 
		else 
		{
			StringBuffer inflected = new StringBuffer().append(prefix).append(
			        root.substring(index1, index2)).append(inside).append(root.substring(index3, index4)).append(suffix);
			
			inflectedVerb = inflected.toString();
			//System.out.println("(F) VerbGenIP: generateBareInfinitive() -- "+inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
		}
		//השתנו הגדרות - לא נכון!!
//		if (inflectInfinitiveIndependent) {
//			setAttributes("infinitive", "verb", "unspecified", "unspecified",
//					"unspecified", "unspecified", "unspecified", "unspecified",
//					"unspecified", "unspecified", "unspecified", "unspecified",
//					"f");
//
//			if (!replaceRemoveException("unspecified", tense, "unspecified",
//					"unspecified", "unspecified", replaceExceptionList, false,
//					REPLACE)
//					&& !replaceRemoveException("unspecified", tense,
//							"unspecified", "unspecified", "unspecified",
//							removeExceptionList, false, REMOVE)) {
//				replaceRemoveInfinitive = false;
//				populateDBTable();
//			} else
//				replaceRemoveInfinitive = true;
//		}

	}

	/**
	 * This method generate the infinitive form <br>
	 * It creates (1) infinitive + possessive forms <br>
	 * (2) l+ infinitive <br>
	 * The infinitive is created from the prefix + root(index1,index2) + inside +
	 * root(index3,index4) +suffix parts <br>
	 * The indexes define the substringing of the root
	 * 
	 * @param prefix -
	 *            concatenate to the begining of the root
	 * @param inside -
	 *            concatenate to the middle of the root
	 * @param index1 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index2 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index3 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param index4 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param suffix -
	 *            concatenate to the end of the root
	 * @throws Exception
	 */
	public void generateInfinitive(String prefix, String inside, int index1,
			int index2, int index3, int index4, String suffix) throws Exception 
		{
		//Bare infinitive is like 'to infinitive' with out the 'to':
		// - by shuly definition לשמור -- שמור
		///////////////////bklm+non inflected infinitive//////////////

		if (inflectInfinitive) 
		{
			//System.out.println("(F)generateInfinitive generate l+infinitive");
			setAttributes("infinitive", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");

			StringBuffer inflected = new StringBuffer().append("l").append(inflectedVerb);

			inflectedVerb = inflected.toString();
			//System.out.println("(F)generateInfinitive inflectedVerb =" + inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.println("(F)generateInfinitive surface =" + surface);
			//System.out.println();

			if (!replaceRemoveException("unspecified", tense, "unspecified",
					"unspecified", "unspecified", replaceExceptionList, false,REPLACE)
					&& !replaceRemoveException("unspecified", tense,
							"unspecified", "unspecified", "unspecified",
							removeExceptionList, false, REMOVE))
				populateDBTable();

			//System.out.println("generate b+infinitive");
			setAttributes("infinitive", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");

			inflected = new StringBuffer().append("b").append(inflectedVerb.substring(1));

			inflectedVerb = inflected.toString();
			//System.out.println("(F)generateInfinitive inflectedVerb =" + inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.println("(F)generateInfinitive surface =" + surface);
			//System.out.println();

			if (!replaceRemoveException("unspecified", tense, "unspecified",
					"unspecified", "unspecified", replaceExceptionList, false,REPLACE)
					&& !replaceRemoveException("unspecified", tense,
							"unspecified", "unspecified", "unspecified",
							removeExceptionList, false, REMOVE))
				populateDBTable();

			//System.out.println("(F)generateInfinitive generate m+infinitive");
			setAttributes("infinitive", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");

			inflected = new StringBuffer().append("m").append(inflectedVerb.substring(1));

			inflectedVerb = inflected.toString();
			//System.out.println("(F)generateInfinitive inflectedVerb =" + inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.println("(F)generateInfinitive surface =" + surface);
			//System.out.println();

			if (!replaceRemoveException("unspecified", tense, "unspecified",
					"unspecified", "unspecified", replaceExceptionList, false,
					REPLACE)
					&& !replaceRemoveException("unspecified", tense,
							"unspecified", "unspecified", "unspecified",
							removeExceptionList, false, REMOVE))
				populateDBTable();

			//System.out.println("(F)generateInfinitive generate k+infinitive");
			setAttributes("infinitive", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");

			inflected = new StringBuffer().append("k").append(inflectedVerb.substring(1));

			inflectedVerb = inflected.toString();
			//System.out.println("(F)generateInfinitive inflectedVerb =" + inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.println("(F)generateInfinitive surface =" + surface);
			//System.out.println();

			if (!replaceRemoveException("unspecified", tense, "unspecified",
					"unspecified", "unspecified", replaceExceptionList, false,
					REPLACE)
					&& !replaceRemoveException("unspecified", tense,
							"unspecified", "unspecified", "unspecified",
							removeExceptionList, false, REMOVE))
				populateDBTable();
		}

			///////////////////////////////////////////////////////////////////////////////
			if (binyan.equals("Pa\\'al") && !replaceRemoveInfinitive) 
			{
				//System.out.println("generate infinitive without prefix l - for bkm prefixes");
				StringBuffer inflected = new StringBuffer().append(prefix).append(
						root.substring(index1, index2)).append(inside).append(
						root.substring(index3, index4)).append(suffix);

				inflectedVerb = inflected.toString();
			} 
			else if(inflectInfinitive)
				inflectedVerb = inflectedVerb.substring(1);

			setAttributes("infinitive", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"possessive", "unspecified", "unspecified", "unspecified",
					"f");
			generateAccusativeNominative(inflectedVerb);

			//////////////////////////////////////////////////////////////
			//System.out.println();
	}

	/**
	 * This method generate the paste form <br>
	 * The past form is created from the prefix + root(index1,index2) + inside +
	 * root(index3,index4) +suffix parts <br>
	 * The indexes define the substringing of the root
	 * 
	 * @param prefix -
	 *            concatenate to the begining of the root
	 * @param suffix -
	 *            concatenate to the end of the root
	 * @param inside -
	 *            concatenate to the middle of the root
	 * @param index1 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index2 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index3 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param index4 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @throws Exception
	 */
	public void generatePast(String prefix, String suffix, String inside,
			int index1, int index2, int index3, int index4) throws Exception 
		{
		if (inflectPast) 
		{
			PGN = "unspecified";
			StringTokenizer stIn1 = null;
			StringTokenizer stPre = null;
			StringTokenizer stSuff = null;

			stSuff = new StringTokenizer(suffix, ",");
			StringTokenizer stPGN9 = new StringTokenizer(PGNTokens9, ",");
			StringTokenizer stPerson9 = new StringTokenizer(personTokens9, ",");
			StringTokenizer stGender9 = new StringTokenizer(genderTokens9, ",");
			StringTokenizer stNumber9 = new StringTokenizer(numberTokens9, ",");

			if (!inside.equals(""))
				stIn1 = new StringTokenizer(inside, ",");
			if (!prefix.equals(""))
				stPre = new StringTokenizer(prefix, ",");

			String linside = "";
			String lprefix = "";
			String lsuffix = "";

			//System.out.println();
			//System.out.println("generate  past");

			while (stSuff.hasMoreTokens()) 
			{
				lsuffix = stSuff.nextToken();
				if (lsuffix.equals("-"))
					lsuffix = "";

				if (stIn1 != null) 
				{
					linside = stIn1.nextToken();
					if (linside.equals("-"))
						linside = "";
				}

				if (stPre != null) 
				{
					lprefix = stPre.nextToken();
					if (lprefix.equals("-"))
						lprefix = "";
				}
				setAttributes("past", "verb", "unspecified", "unspecified",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "f");
				StringBuffer inflected = new StringBuffer().append(lprefix)
						.append(root.substring(index1, index2)).append(linside)
						.append(root.substring(index3, index4)).append(lsuffix);
				inflectedVerb = inflected.toString();
				//System.out.println("inflectedVerb =" + inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.println("surface =" + surface);
				//System.out.println();
				basePerson = stPerson9.nextToken();
				baseNumber = stNumber9.nextToken();
				baseGender = stGender9.nextToken();

				if (!replaceRemoveException("unspecified", tense, baseGender,
						baseNumber, basePerson, replaceExceptionList, false,
						REPLACE)
						&& !replaceRemoveException("unspecified", tense,
								baseGender, baseNumber, basePerson,
								removeExceptionList, false, REMOVE))
					populateDBTable();
			}
		}
	}

	public void generatePastFromBaseForm(String baseForm, String suffix) throws Exception 
		{
		PGN = "unspecified";
		StringTokenizer stSuff = null;
		String lsuffix = "";

		stSuff = new StringTokenizer(suffix, ",");
		StringTokenizer stPGN9 = new StringTokenizer(PGNTokens9, ",");
		StringTokenizer stPerson9 = new StringTokenizer(personTokens9, ",");
		StringTokenizer stGender9 = new StringTokenizer(genderTokens9, ",");
		StringTokenizer stNumber9 = new StringTokenizer(numberTokens9, ",");

		//System.out.println();
		//System.out.println("generate  past");

		while (stSuff.hasMoreTokens()) 
		{
			lsuffix = stSuff.nextToken();
			if (lsuffix.equals("-"))
				lsuffix = "";

			setAttributes("past", "verb", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");
			StringBuffer inflected = new StringBuffer().append(baseForm)
					.append(lsuffix);
			inflectedVerb = inflected.toString();
			//System.out.println("inflectedVerb =" + inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.println("surface =" + surface);
			//System.out.println();
			basePerson = stPerson9.nextToken();
			baseNumber = stNumber9.nextToken();
			baseGender = stGender9.nextToken();
			if (!replaceRemoveException("unspecified", tense, baseGender,
					baseNumber, basePerson, replaceExceptionList, false,
					REPLACE)
					&& !replaceRemoveException("unspecified", tense,
							baseGender, baseNumber, basePerson,
							removeExceptionList, false, REMOVE))
				populateDBTable();
		}
	}

	/**
	 * This method generate the beinoni form <br>
	 * The construct from is generated from the 123/M/Sg form We create the
	 * possessive form from the construct form for all binyans except for <br>
	 * נפעל , פועל ו והופעל
	 * 
	 * @param prefix -
	 *            concatenate to the begining of the root
	 * @param suffix -
	 *            concatenate to the end of the root
	 * @param inside -
	 *            concatenate to the middle of the root
	 * @param index1 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index2 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index3 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param index4 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @throws Exception
	 */

	public void generatePresent(String prefix, String suffix, String inside,
			int index1, int index2, int index3, int index4) throws Exception 
		{
		if (inflectBeinoni) 
		    {
			StringTokenizer stIn = null;
			StringTokenizer stPre = null;
			StringTokenizer stNumber4 = null;
			StringTokenizer stGender4 = null;
			StringTokenizer stPerson4 = null;
			StringTokenizer stSuff = null;

			stGender4 = new StringTokenizer(genderTokens4, ",");
			stNumber4 = new StringTokenizer(numberTokens4, ",");
			stPerson4 = new StringTokenizer(personTokens4, ",");
			stSuff = new StringTokenizer(suffix, ",");

			if (!inside.equals("")) 
			{
				stIn = new StringTokenizer(inside, ",");
			}

			if (!prefix.equals("")) 
			{
				stPre = new StringTokenizer(prefix, ",");
			}

			String linside = "";
			String lprefix = "";
			String lsuffix = "";

			//System.out.println();
			//System.out.println("generate participle");

			boolean constructFlag = false;

			while (stSuff.hasMoreTokens()) 
			{
				lsuffix = stSuff.nextToken();
				if (lsuffix.equals("-"))
					lsuffix = "";

				if (stIn != null) 
				{
					linside = stIn.nextToken();
					if (linside.equals("-"))
						linside = "";
				}
				if (stPre != null) 
				{
					lprefix = stPre.nextToken();
					if (lprefix.equals("-"))
						lprefix = "";
				}

				setAttributes("beinoni", "participle", "unspecified",
						basePerson, baseGender, baseNumber, "false",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "tf");

				baseNumber = stNumber4.nextToken();
				baseGender = stGender4.nextToken();
				basePerson = stPerson4.nextToken();

				//I don't remember why the following commented lines exists
				// ????????????????????
				//				if (lsuffix.equals("") && linside.equals("") &&
				//				 lprefix.equals("")) {
				//					constructFlag = true;
				//					continue;
				//				}

				StringBuffer inflected = new StringBuffer().append(lprefix)
						.append(root.substring(index1, index2)).append(linside)
						.append(root.substring(index3, index4)).append(lsuffix);

				inflectedVerb = inflected.toString();
				//System.out.println("inflectedVerb =" + inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.println("surface =" + surface);
				//System.out.println();

				//for comparing in the repalceRemove
				//				String PGNNumner = "";
				//				if (baseNumber.equals("singular"))
				//					PGNNumner = "Sg";
				//				else
				//					PGNNumner = "Pl";
				//				if (basePerson.equals("any"))
				//					PGN = "123p/" + baseGender.substring(0, 1).toUpperCase()
				//							+ "/" + PGNNumner;
				//				else
				//					PGN = basePerson + "/"
				//							+ baseGender.substring(0, 1).toUpperCase() + "/"
				//							+ PGNNumner;
				if (!replaceRemoveException("unspecified", tense, baseGender,
						baseNumber, basePerson, replaceExceptionList, false,
						REPLACE)
						&& !replaceRemoveException(PGN, tense, baseGender,
								baseNumber, basePerson, removeExceptionList,
								false, REMOVE)) 
				{
					PGN = "unspecified";

					// - הכל יכול להיות - לא מיודע, לא קניין , לא נסמך
					participleType = "noun";
					populateDBTable();
					participleType = "verb";
					populateDBTable();
					participleType = "adjective";
					populateDBTable();

				}

				//generate h + beinoni - השומר
				inflectedVerb = "h" + inflectedVerb;
				setAttributes("beinoni", "participle", "unspecified",
						basePerson, baseGender, baseNumber, "false",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "tt");
				surface = Translate.Eng2Heb(inflectedVerb);

				////////////////////////////

				participleType = "noun";
				populateDBTable();
				participleType = "adjective";
				populateDBTable();
				participleType = "verb";
				baseDefiniteness = "s";
				populateDBTable();

				///////////////////////////
				//System.out.println("h+ participle =" + inflectedVerb);
				setAttributes("beinoni", "participle", "unspecified",
						basePerson, baseGender, baseNumber, "false",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "tf");
				inflectedVerb = inflectedVerb.substring(1);
				surface = Translate.Eng2Heb(inflectedVerb);

				//The construct form is created from the 123/M/Sg form

				//the generation of the possessive form is determaind by two
				// values:
				//1) possessive flag - determined according to the binyan - we
				// will not generate possessive form for binyan nifal, hufal and
				// pual
				//2) the beinoniPossessive form set by the user in the lexicon
				if (!constructFlag) 
				{
					if (((intInflectedPattern >= 1) && (intInflectedPattern < 36))
							|| ((intInflectedPattern >= 42) && intInflectedPattern <= 53))
						generateConstructAndPossessive(inflectedVerb, true);
					else
						generateConstructAndPossessive(inflectedVerb, false);
					constructFlag = true;
					PGN = "unspecified";
				}
			}
		}
	}

	/**
	 * This method generates the future form
	 * 
	 * @param prefix -
	 *            concatenate to the begining of the root
	 * @param suffix -
	 *            concatenate to the end of the root
	 * @param inside -
	 *            concatenate to the middle of the root
	 * @param index1 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index2 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index3 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param index4 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @throws Exception
	 */
	public void generateFuture(String prefix, String suffix, String inside,
			int index1, int index2, int index3, int index4) throws Exception 
		{
		if (inflectFuture) 
		    {
			StringTokenizer stIn = null;
			StringTokenizer stPre = new StringTokenizer(prefix, ",");
			StringTokenizer stSuff = new StringTokenizer(suffix, ",");
			final String genderTokens10 = "masculine and feminine,masculine,feminine,masculine,feminine,masculine and feminine,masculine and feminine,feminine,masculine and feminine,feminine";
			//final String PGNTokens10 =
			// "1p/MF/Sg,2p/M/Sg,2p/F/Sg,3p/M/Sg,3p/F/Sg,1p/MF/Pl,2p/MF/Pl,2p/F/Pl,3p/MF/Pl,3p/F/Pl";
			stPerson10 = new StringTokenizer(personTokens10, ",");
			stGender10 = new StringTokenizer(genderTokens10, ",");
			stNumber10 = new StringTokenizer(numberTokens10, ",");

			if (!inside.equals(""))
				stIn = new StringTokenizer(inside, ",");
			stPGN10 = new StringTokenizer(PGNTokens10, ",");

			String linside = "";
			String lpreffix = "";
			String lsuffix = "";

			//System.out.println();
			//System.out.println("generate future");

			setAttributes("future", "verb", "unspecified", "any",
					"unspecified", "unspecified", "false", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");
			while (stPre.hasMoreTokens()) 
			{
				lpreffix = stPre.nextToken();
				if (lpreffix.equals("-"))
					lpreffix = "";
				lsuffix = stSuff.nextToken();
				if (lsuffix.equals("-"))
					lsuffix = "";
				if (stIn != null) 
				{
					linside = stIn.nextToken();
					if (linside.equals("-"))
						linside = "";
				}

				StringBuffer inflected = new StringBuffer().append(lpreffix)
						.append(root.substring(index1, index2)).append(linside)
						.append(root.substring(index3, index4)).append(lsuffix);
				inflectedVerb = inflected.toString();
				//System.out.println("inflectedVerb =" + inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.println("surface =" + surface);
				//System.out.println();

				PGN = "unspecified";
				basePerson = stPerson10.nextToken();
				baseNumber = stNumber10.nextToken();
				baseGender = stGender10.nextToken();
				if (!replaceRemoveException("unspecified", tense, baseGender,
						baseNumber, basePerson, replaceExceptionList, false,
						REPLACE)
						&& !replaceRemoveException("unspecified", tense,
								baseGender, baseNumber, basePerson,
								replaceExceptionList, false, REMOVE))
					populateDBTable();
				//ייצור צורת עתיד יחיד או רבים גוף שלישי עם י אחת במקום שתיים
				if (binyan.equals("Nif\\'al")) 
				{
					if ((baseGender.equals("masculine")
							&& baseNumber.equals("singular") && basePerson
							.equals("3"))
							|| (baseGender.equals("masculine and feminine")
									&& baseNumber.equals("plural") && basePerson.equals("3"))) 
					{
						if (!replaceRemoveException("unspecified", tense,
								baseGender, baseNumber, basePerson,
								replaceExceptionList, false, REMOVE)
								&& !replaceRemoveException("unspecified",
										tense, baseGender, baseNumber,
										basePerson, replaceExceptionList,
										false, REPLACE)) 
						{
							inflectedVerb = inflectedVerb.substring(1);
							//		inflectedVerb = inflected.toString();
							String originalSpalling = spelling;
							spelling = "irregular";
							surface = Translate.Eng2Heb(inflectedVerb);
							populateDBTable();
							spelling = originalSpalling;
						}
					}
				}
			}
		}
	}

	/**
	 * This method generates the imperative form
	 * 
	 * @param suffix -
	 *            concatenate to the end of the root
	 * @param inside -
	 *            concatenate to the middle of the root
	 * @param index1 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index2 -
	 *            substringing the root from index1 to index2 for concatenation
	 *            of the inside part
	 * @param index3 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @param index4 -
	 *            substringing the root from index3 to index4 for concatenation
	 *            of the inside part
	 * @throws Exception
	 */
	public void generateImperative(String prefix, String suffix, String inside,
			int index1, int index2, int index3, int index4) throws Exception 
		{
		if (inflectImperative) 
		    {
			StringTokenizer stIn = null;
			StringTokenizer stSuff = null;

			String genderImperative = "masculine,feminine,masculine and feminine,feminine";

			stGender4 = new StringTokenizer(genderImperative, ",");
			stNumber4 = new StringTokenizer(numberTokens4, ",");
			//stPGNImperative = new StringTokenizer(PGNTokensImperative, ",");
			if (!inside.equals(""))
				stIn = new StringTokenizer(inside, ",");
			stSuff = new StringTokenizer(suffix, ",");

			String linside = "";
			String loutside = "";
			String lsuffix = "";
			//System.out.println();
			//System.out.println("generate imperative");

			setAttributes("imperative", "verb", "unspecified", "2",
					"unspecified", "unspecified", "false", "unspecified",
					"unspecified", "unspecified", "unspecified", "unspecified",
					"f");
			while (stSuff.hasMoreTokens()) 
			{
				if (stIn != null) 
				{
					linside = stIn.nextToken();
					if (linside.equals("-"))
						linside = "";
				}
				lsuffix = stSuff.nextToken();
				if (lsuffix.equals("-"))
					lsuffix = "";

				StringBuffer inflected = new StringBuffer().append(prefix)
						.append(root.substring(index1, index2)).append(linside)
						.append(root.substring(index3, index4)).append(lsuffix);
				inflectedVerb = inflected.toString();
				//System.out.println("inflectedVerb =" + inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.println("surface =" + surface);
				//System.out.println();

				//PGN = stPGNImperative.nextToken();
				baseNumber = stNumber4.nextToken();
				baseGender = stGender4.nextToken();
				basePerson = "2";

				if (!replaceRemoveException("unspecified", tense, baseGender,
						baseNumber, basePerson, replaceExceptionList, false,
						REPLACE)
						&& !replaceRemoveException("unspecified", tense,
								baseGender, baseNumber, basePerson,
								removeExceptionList, false, REMOVE))
					populateDBTable();
			}
		}
	}

	/**
	 * This method generate the beinoni paul (only for binyan Paal)
	 * 
	 * @param passiveBase -
	 *            the base form on which the generation works
	 * @throws Exception
	 */
	public void generateBeinoniPassive(String passiveBase) throws Exception 
	{
		if (valence.indexOf("WithoutPaul") == -1) 
		{
			//System.out.println();
			//System.out.println("generateBeinoniPassive");
			StringTokenizer stSuff = null;
			StringTokenizer stNumber4 = null;
			StringTokenizer stGender4 = null;

			String passivSuff = "-,h,im,wt";
			stSuff = new StringTokenizer(passivSuff, ",");
			stNumber4 = new StringTokenizer(numberTokens4, ",");
			stGender4 = new StringTokenizer(genderTokens4, ",");
			boolean constructFlag = false;

			while (stSuff.hasMoreTokens()) 
			{
				setAttributes("beinoni", "passiveParticiple", "unspecified",
						"any", "unspecified", "unspecified", "false",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "f");
				baseNumber = stNumber4.nextToken();
				baseGender = stGender4.nextToken();
				String suffix = stSuff.nextToken();
				if (suffix.equals("-"))
					suffix = "";
				StringBuffer inflect = new StringBuffer().append(passiveBase).append(suffix);
				inflectedVerb = inflect.toString();
				surface = Translate.Eng2Heb(inflectedVerb);

				//System.out.println("surface =" + surface);
				//System.out.println();

				participleType = "adjective";

				populateDBTable();

				inflectedVerb = "h" + inflectedVerb;
				setAttributes("beinoni", "passiveParticiple", "unspecified",
						"any", baseGender, baseNumber, "false", "unspecified",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "tt");
				surface = Translate.Eng2Heb(inflectedVerb);

				participleType = "noun";
				populateDBTable();
				participleType = "adjective";
				populateDBTable();
				participleType = "verb";
				baseDefiniteness = "s"; //subcoordination
				populateDBTable();

				//System.out.println("h+ participle =" + inflectedVerb);
				setAttributes("beinoni", "passiveParticiple", "unspecified",
						basePerson, baseGender, baseNumber, "false",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "unspecified", "f");
				inflectedVerb = inflect.toString();
				surface = Translate.Eng2Heb(inflectedVerb);

				if (!constructFlag) 
				{
					//morphological changes
					String base = "";
					if (root.charAt(1) == 'w' || root.charAt(1) == 'i')
						base = passiveBase;
					else if (root.charAt(2) == 'h' || root.charAt(2) == 'i')
						base = root.substring(0, 2) + "wi";
					else if (root.charAt(2) == 'a'
							&& passiveBase.charAt(3) == 'a')
						base = root.substring(0, 2) + "w" + root.substring(2);
					else if (root.charAt(2) == 'a'
							&& passiveBase.charAt(3) == 'i')
						base = root.substring(0, 2) + "wi";
					else
						base = root.substring(0, 2) + "w" + root.substring(2);
					generateConstructAndPossessive(base, false);
					constructFlag = true;
				}
			}
		}
	}

	/**
	 * This method generates the construct form out of the 123/M/Sg form
	 * 
	 * @param base -
	 *            the 123/M/Sg form
	 * @param possessiveFlag -
	 *            for Nifal,Pual,Hufal - false - because we will not generete
	 *            the possessive form
	 * @throws Exception
	 */
	public void generateConstructAndPossessive(String base,boolean possessiveFlag) throws Exception 
		{
		if (inflectBeinoniConstruct) 
		    {
			String passivSuff = "";
			//System.out.println();
			//System.out.println("generateConstructAndPossessive");
			StringTokenizer stSuff = null;
			if (base.endsWith("wwh"))
				passivSuff = "h,it,i,t";
			else if (base.endsWith("h"))
				passivSuff = "h,t,i,wt";
			else
				passivSuff = "-,t,i,wt";
			stNumber4 = new StringTokenizer(numberTokens4, ",");
			stGender4 = new StringTokenizer(genderTokens4, ",");
			stPerson4 = new StringTokenizer(personTokens4, ",");
			//StringTokenizer stPGNTokensBeinoni = new StringTokenizer(
			//PGNTokensBeinoni, ",");
			stSuff = new StringTokenizer(passivSuff, ",");

			//Morphological changes:
			if (base.endsWith("h"))
				base = base.substring(0, base.length() - 1);
			while (stNumber4.hasMoreTokens()) 
			{
				setAttributes("beinoni", pos, "unspecified", basePerson,
						baseGender, baseNumber, "true", "unspecified",
						"unspecified", "unspecified", "unspecified",
						"unspecified", "f");
				baseNumber = stNumber4.nextToken();
				baseGender = stGender4.nextToken();
				basePerson = stPerson4.nextToken();
				//PGN = stPGNTokensBeinoni.nextToken();
				String suff = stSuff.nextToken();
				if (suff.equals("-"))
					suff = "";

				StringBuffer inflected = new StringBuffer().append(base).append(suff);
				inflectedVerb = inflected.toString();
				//System.out.print("inflectedVerb =" + inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.print("surface =" + surface);
				//System.out.println();

				boolean rtRemove = replaceRemoveException("unspecified", tense,
						baseGender, baseNumber, basePerson,
						replaceExceptionList, true, REMOVE);
				boolean rtReplace = replaceRemoveException("unspecified",
						tense, baseGender, baseNumber, basePerson,
						replaceExceptionList, true, REPLACE);

				if (!rtRemove && !rtReplace) 
				{
					//עבור צורות הנסמך תכונת היידוע לא רלבנטית
					definitenessVal = "unspecified";
					//רק שם עצם יכול להיות נסמך

					if (surface.equals("קטוע") || surface.equals("נטול"))
						participleType = "adjective";
					else
						participleType = "noun";

					populateDBTable();
					definitenessVal = "tf";
					//					possessive flag is false for nifal, hufal and pual - the
					// possessive form will
					// not be created for these binyanim
					if (possessiveFlag && inflectBeinoniPossessive) 
					{
						generatePossessive(inflectedVerb);
					}
					//exceptionInflectBeinoniPossessive still doesn't work well
					// - to do someday
				} 
				else if (rtReplace && possessiveFlag
						&& exceptionInflectBeinoniPossessive)
					generatePossessive(inflectedVerb);
			}
		}
	}

	private void generatePossessiveColloquial(String base) throws Exception 
	{
		//    	handling exceptions for feminine, plural
		participleType = "noun";
		String currentSpelling = spelling;
		if (baseGender.equals("feminine") && baseNumber.equals("plural")) 
		{
			if (PGN.equals("1p/MF/Sg")) 
			{
				inflectedVerb = base + "i";
				if (currentSpelling.equals("standard"))
					spelling = "irregular";
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			} 
			else if (PGN.equals("2p/F/Sg")) 
			{
				inflectedVerb = base + "ik";
				if (currentSpelling.equals("standard"))
					spelling = "irregular";
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			}
			//			if (currentScript.equals("formal"))
			//				script = "formal";
			//			else if (currentScript.equals("slang"))
			//				script = "slang";
			spelling = currentSpelling;

		}
		//				handling exceptions for feminine, plural
		if (baseGender.equals("masculine") && baseNumber.equals("plural")) 
		{
			if (PGN.equals("1p/MF/Sg")) 
			{
				inflectedVerb = base;
				if (currentSpelling.equals("standard"))
					spelling = "irregular";
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			} 
			else if (PGN.equals("2p/F/Sg")) 
			{
				inflectedVerb = base + "k";
				if (currentSpelling.equals("standard"))
					spelling = "irregular";
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			}
			spelling = currentSpelling;
			//			if (currentScript.equals("formal"))
			//				script = "formal";
			//			else if (currentScript.equals("slang"))
			//				script = "slang";
		}
	}

	/**
	 * This method generate the possessive form out of the 123/M/Sg form
	 * 
	 * @param base -
	 *            the base form from which the possessive form will be created
	 * @throws Exception
	 */
	public void generatePossessive(String base) throws Exception 
	{
		//System.out.println();
		//System.out.println("generatePossessive");
		StringTokenizer stSuff = null;
		StringTokenizer stPerson = new StringTokenizer(personTokens10, ",");
		StringTokenizer stNumber = new StringTokenizer(numberTokens10, ",");
		StringTokenizer stGender = new StringTokenizer(genderTokens10, ",");
		String suff;

		setAttributes(tense, pos, "unspecified", basePerson, baseGender,
				baseNumber, "false", "unspecified", "possessive",
				"unspecified", "unspecified", "unspecified", "f");
		stPGN10 = new StringTokenizer(PGNTokens10, ",");

		//morphological changes:
		if (base.endsWith("h"))
			base = base.substring(0, base.length() - 1);
		//System.out.println("baseNumber = " + baseNumber);
		//System.out.println("baseGender = " + baseGender);
		if (baseGender.equals("feminine") && baseNumber.equals("plural"))
			suff = suffixFPlural;
		else if (baseGender.equals("masculine") && baseNumber.equals("plural"))
			suff = suffixMPlural;
		else
			suff = suffixSingular;
		//System.out.println("suff=" + suff);
		stSuff = new StringTokenizer(suff, ",");
		String suffPossessive;
		while (stPGN10.hasMoreTokens()) 
		{
			PGN = stPGN10.nextToken();
			suffPossessive = stSuff.nextToken();
			if (suffPossessive.equals("-"))
				suffPossessive = "";
			inflectedVerb = base + suffPossessive;
			if (inflectedVerb.endsWith("www"))
				inflectedVerb = inflectedVerb.substring(0, inflectedVerb.length() - 1);
			//System.out.println(inflectedVerb);
			surface = Translate.Eng2Heb(inflectedVerb);
			//System.out.print("surface =" + surface);
			//System.out.println();
			//רק שם עצם יכול להיות עם קניין

			participleType = "noun";
			populateDBTable();
			generatePossessiveColloquial(base);
		}
	}

	/**
	 * This method generate the possessive form out of the 123/M/Sg form
	 * 
	 * @param base -
	 *            the base form from which the possessive form will be created
	 * @throws Exception
	 */
	public void generateAccusativeNominative(String base) throws Exception 
	{
		//System.out.println();
		//System.out.println("generateAccusativenNominative");
		StringTokenizer stSuff = null;
		StringTokenizer stPerson = new StringTokenizer(personTokens10, ",");
		StringTokenizer stNumber = new StringTokenizer(numberTokens10, ",");
		StringTokenizer stGender = new StringTokenizer(genderTokens10, ",");
		String suff;

		setAttributes(tense, pos, "unspecified", basePerson, baseGender,
				baseNumber, "false", "unspecified", "accusative or nominative",
				"unspecified", "unspecified", "unspecified", "f");
		stPGN10 = new StringTokenizer(PGNTokens10, ",");

		//morphological changes:
		//if (base.endsWith("h"))
		//	base = base.substring(0, base.length() - 1);
		//System.out.println("baseNumber = " + baseNumber);
		//System.out.println("baseGender = " + baseGender);
		if (baseGender.equals("feminine") && baseNumber.equals("plural"))
			suff = suffixFPlural;
		else if (baseGender.equals("masculine") && baseNumber.equals("plural"))
			suff = suffixMPlural;
		else
			suff = suffixSingular;
		//System.out.println("suff=" + suff);
		stSuff = new StringTokenizer(suff, ",");
		String suffPossessive;
		while (stPGN10.hasMoreTokens()) 
		{
			PGN = stPGN10.nextToken();
			suffPossessive = stSuff.nextToken();
			if (suffPossessive.equals("-"))
				suffPossessive = "";
			inflectedVerb = base + suffPossessive;

			if (inflectInfinitiveb) 
			{
				if (inflectInfinitiveIndependent)
				{
				pos = "indInf";
				//System.out.println(inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				//System.out.print("surface =" + surface);
				//System.out.println();
				populateDBTable();
				pos = "verb";
				}
			}

			//generate l + inflectedInfinitive just for יוצא or עומד with
			// inflectInfinitive = true
			if (inflectInfinitivel) 
			{
				inflectedVerb = "l" + inflectedVerb;
				//System.out.println(inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			}

			//generate b+ inflectedInfinitive for all verbs
			if (inflectInfinitiveb) 
			{
				if (inflectInfinitivel)
					inflectedVerb = "b" + inflectedVerb.substring(1);
				else
					inflectedVerb = "b" + inflectedVerb;
				//System.out.println(inflectedVerb);
				surface = Translate.Eng2Heb(inflectedVerb);
				populateDBTable();
			}
		}
	}

	public static void main(String[] args) 
	{
	}

	/**
	 * @param baseLexiconPointer
	 *            The baseLexiconPointer to set.
	 */
	public void setBaseLexiconPointer(String baseLexiconPointer) 
	{
		this.baseLexiconPointer = baseLexiconPointer;
	}

	/**
	 * @param baseTransliterated
	 *            The baseTransliterated to set.
	 */
	public void setBaseTransliterated(String baseTransliterated) 
	{
		this.baseTransliterated = baseTransliterated;
	}

	/**
	 * @param baseUndot
	 *            The baseUndot to set.
	 */
	public void setBaseUndot(String baseUndot) 
	{
		this.baseUndot = baseUndot;
	}

	/**
	 * @param binyan
	 *            The binyan to set.
	 */
	public void setBinyan(String binyan) 
	{
		this.binyan = binyan;
	}

	/**
	 * @param root
	 *            The root to set.
	 */
	public void setRoot(String root) 
	{
		this.root = root;
	}

	/**
	 *  
	 */
	public void setRegister(String register) 
	{
		this.register = register;
	}

	/**
	 *  
	 */
	public void setSpelling(String spelling) 
	{
		this.spelling = spelling;
	}

	/**
	 * @param removeExceptionList
	 *            The removeExceptionList to set.
	 */
	public void setRemoveExceptionList(List removeExceptionList) 
	{
		this.removeExceptionList = removeExceptionList;
	}

	/**
	 * @return Returns the valence.
	 */
	public String getValence() 
	{
		return valence;
	}

	/**
	 * @param valence
	 *            The valence to set.
	 */
	public void setValence(String valence) 
	{
		this.valence = valence;
	}

	/**
	 * @return Returns the dottedLexiconItem.
	 */
	public String getDottedLexiconItem() 
	{
		return dottedLexiconItem;
	}

	/**
	 * @param dottedLexiconItem
	 *            The dottedLexiconItem to set.
	 */
	public void setDottedLexiconItem(String dottedLexiconItem) 
	{
		this.dottedLexiconItem = dottedLexiconItem;
	}

	/**
	 * @return Returns the inflectInfintive.
	 */
	public boolean isInflectInfinitivel() 
	{
		return inflectInfinitivel;
	}

	/**
	 * @param inflectInfintive
	 *            The inflectInfintive to set.
	 */
	public void setInflectInfinitivel(boolean inflectInfintivel) 
	{
		this.inflectInfinitivel = inflectInfintivel;
	}

	/**
	 * @return Returns the inflectInfintive.
	 */
	public boolean isInflectInfinitiveb() 
	{
		return inflectInfinitiveb;
	}

	/**
	 * @param inflectInfintive
	 *            The inflectInfintive to set.
	 */
	public void setInflectInfinitiveb(boolean inflectInfintiveb) 
	{
		this.inflectInfinitiveb = inflectInfintiveb;
	}

	/**
	 * @return Returns the inflectBeinoni.
	 */
	public boolean isInflectBeinoni() 
	{
		return inflectBeinoni;
	}

	/**
	 * @param inflectBeinoni
	 *            The inflectBeinoni to set.
	 */
	public void setInflectBeinoni(boolean inflectBeinoni) 
	{
		this.inflectBeinoni = inflectBeinoni;
	}

	/**
	 * @return Returns the independent.
	 */
	public boolean isInflectInfinitiveIndependent() 
	{
		return inflectInfinitiveIndependent;
	}

	/**
	 * @param independent
	 *            The independent to set.
	 */
	public void setInflectInfinitiveIndependent(boolean inflectInfinitiveIndependent) 
	{
		this.inflectInfinitiveIndependent = inflectInfinitiveIndependent;
	}

	/**
	 * @param replaceExceptionList
	 *            The replaceExceptionList to set.
	 */
	public void setReplaceExceptionList(List replaceExceptionList) 
	{
		this.replaceExceptionList = replaceExceptionList;
	}

	/**
	 * @param replaceRemoveInfinitive
	 *            The replaceRemoveInfinitive to set.
	 */
	public void setReplaceRemoveInfinitive(boolean replaceRemoveInfinitive) 
	{
		this.replaceRemoveInfinitive = replaceRemoveInfinitive;
	}

	/**
	 * @return Returns the inflectBeinoniConstruct.
	 */
	public boolean isInflectBeinoniConstruct() 
	{
		return inflectBeinoniConstruct;
	}

	/**
	 * @param inflectBeinoniConstruct
	 *            The inflectBeinoniConstruct to set.
	 */
	public void setInflectBeinoniConstruct(boolean inflectBeinoniConstruct) 
	{
		this.inflectBeinoniConstruct = inflectBeinoniConstruct;
	}

	/**
	 * @return Returns the inflectBeinoniPossessive.
	 */
	public boolean isInflectBeinoniPossessive() 
	{
		return inflectBeinoniPossessive;
	}

	/**
	 * @param inflectBeinoniPossessive
	 *            The inflectBeinoniPossessive to set.
	 */
	public void setInflectBeinoniPossessive(boolean inflectBeinoniPossessive) 
	{
		this.inflectBeinoniPossessive = inflectBeinoniPossessive;
	}

	/**
	 * @return Returns the inflectedVerb.
	 */
	public String getInflectedVerb() 
	{
		return inflectedVerb;
	}

	/**
	 * @param inflectedVerb
	 *            The inflectedVerb to set.
	 */
	public void setInflectedVerb(String inflectedVerb) 
	{
		this.inflectedVerb = inflectedVerb;
	}

	/**
	 * @return Returns the inflectPast.
	 */
	public boolean isInflectPast() 
	{
		return inflectPast;
	}

	/**
	 * @param inflectPast
	 *            The inflectPast to set.
	 */
	public void setInflectPast(boolean inflectPast) 
	{
		this.inflectPast = inflectPast;
	}

	/**
	 * @return Returns the inflectImperative.
	 */
	public boolean isInflectImperative() 
	{
		return inflectImperative;
	}

	/**
	 * @param inflectImperative
	 *            The inflectImperative to set.
	 */
	public void setInflectImperative(boolean inflectImperative) 
	{
		this.inflectImperative = inflectImperative;
	}

	/**
	 * @return Returns the inflectFuture.
	 */
	public boolean isInflectFuture() 
	{
		return inflectFuture;
	}

	/**
	 * @param inflectFuture
	 *            The inflectFuture to set.
	 */
	public void setInflectFuture(boolean inflectFuture) 
	{
		this.inflectFuture = inflectFuture;
	}

	/**
	 * @return Returns the inflectBareInfinitive.
	 */
	public boolean isInflectBareInfinitive() 
	{
		return inflectBareInfinitive;
	}

	/**
	 * @param inflectBareInfinitive
	 *            The inflectBareInfinitive to set.
	 */
	public void setInflectBareInfinitive(boolean inflectBareInfinitive) 
	{
		this.inflectBareInfinitive = inflectBareInfinitive;
	}

	/**
	 * @return Returns the inflectInfinitive.
	 */
	public boolean isInflectInfinitive() 
	{
		return inflectInfinitive;
	}

	/**
	 * @param inflectInfinitive
	 *            The inflectInfinitive to set.
	 */
	public void setInflectInfinitive(boolean inflectInfinitive) 
	{
		this.inflectInfinitive = inflectInfinitive;
	}
	
	public void setTable(String _table)
	{
		this.table = _table;
	}
}
